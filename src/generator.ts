import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

// Type definitions
interface SiteConfig {
  url: string;
  title: string;
  tagline?: string;
}

interface I18nConfig {
  locales: string[];
  defaultLocale: string;
}

interface DocsaurusContext {
  siteDir: string;
  siteConfig: SiteConfig;
  i18n?: I18nConfig;
}

interface FrontMatterSchema {
  type?: string;
  headline?: string;
  image?: string;
  description?: string;
  keywords?: string[];
  datePublished?: string;
  dateModified?: string;
}

interface FrontMatterData {
  schema?: FrontMatterSchema;
  slug?: string;
  title?: string;
  description?: string;
  image?: string;
  date?: string;
}

interface PluginOptions {
  verbose?: boolean;
  baseSchema?: Record<string, unknown>;
  i18n?: Record<string, unknown>;
  outputFile?: string;
  defaultImage?: string;
  sameAsDefault?: string[];
  srcDir?: string;
  blogDir?: string;
  docsDir?: string;
}

// Logger utility
type LogLevel = 'info' | 'warn' | 'error';

function logger(level: LogLevel, message: string, verbose?: boolean): void {
  // Only log 'info' if verbose is enabled, always log warnings and errors
  if (level === 'info' && !verbose) {
    return;
  }

  if (level === 'error') {
    console.error(message);
  } else if (level === 'warn') {
    console.warn(message);
  } else {
    console.log(message);
  }
}

interface BaseSchemaData {
  person?: Record<string, unknown>;
  organization?: Record<string, unknown>;
  website?: Record<string, unknown>;
}

// Function to generate the content of Root.js
function generateFileContent(context: DocsaurusContext, mainI18nData: Record<string, any>, pagesData: string): string {
  const i18n = context.i18n;
  const localesJson = i18n && i18n.locales ? JSON.stringify(i18n.locales) : '[]';
  const defaultLocale = i18n?.defaultLocale ?? 'en-US';

  const startPart: string = `
// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file was generated by plugin-generate-structured-data.
// To update, modify the source markdown files or the plugin configuration and re-run the generator.

import React from 'react';
import { useLocation } from '@docusaurus/router';

export default function Root({ children }) {
  const location = useLocation();

  const baseUrl = ${JSON.stringify(context.siteConfig.url)};
  const currentPath = location.pathname;
  const fullUrl = baseUrl + currentPath;
  const locales = ${localesJson};

    `;

  const endPart: string = `
  // Get the schema for the current page
  const contentData = schemas[location.pathname];
  if (contentData) {
    let isSupportedType = true;
    const schemaType = contentData['@type'];
    const articlesWithAuthorPublisher = ['Article', 'BlogPosting', 'CollectionPage', 'Blog', 'AboutPage'];
    const servicesWithProvider = ['Service', 'WebSite'];

    if (articlesWithAuthorPublisher.includes(schemaType)) {
      contentData.author = {
        '@id': \`\${baseUrl}/#person\`
      };
      contentData.publisher = {
        '@id': \`\${baseUrl}/#organization\`
      };
    } else if (servicesWithProvider.includes(schemaType)) {
      contentData.provider = {
        '@id': \`\${baseUrl}/#organization\`
      };
    } else if (schemaType === 'Organization' || schemaType === 'Person') {
      // No automatic enrichment for these types
    } else {
      isSupportedType = false;
      console.warn(\`No schema.org handling for type: \${schemaType} on path: \${location.pathname}\`);
    }

    if (isSupportedType) {
        contentData.url = fullUrl;
        contentData.mainEntityOfPage = {
        '@type': 'WebPage',
        '@id': \`\${fullUrl}#webpage\`
        };
    }
  }

  // Build the full graph
  let graphData = null;
  const key = location.pathname.split('/')[1];
  let selectedPersonData = null;
  let selectedOrgData = null;
  let selectedWebsiteData = null;
  let currentLocale;
  if (locales.includes(key) && mainI18nData[key]) {
    currentLocale = key;
    // localized data
    selectedPersonData = mainI18nData[key].baseSchema ? mainI18nData[key].baseSchema.person : null;
    selectedOrgData = mainI18nData[key].baseSchema ? mainI18nData[key].baseSchema.organization : null;
    selectedWebsiteData = mainI18nData[key].baseSchema ? mainI18nData[key].baseSchema.website : null;
  }
  else {
    // default data
    selectedPersonData = mainI18nData['default'].baseSchema.person;
    selectedOrgData = mainI18nData['default'].baseSchema.organization;
    selectedWebsiteData = mainI18nData['default'].baseSchema.website;
  }

    // webpage data
    const webPageData = {
      '@type': 'WebPage',
      '@id': \`\${fullUrl}#webpage\`,
      url: fullUrl,
      name: contentData && contentData.headline ? contentData.headline : '${context.siteConfig.title}',
      description: contentData && contentData.description ? contentData.description : undefined,
      inLanguage: currentLocale || 'en-US',
      isPartOf: {
        '@id': \`\${baseUrl}/#website\`
      },
      author: contentData ? contentData.author : undefined,
      publisher: contentData ? contentData.publisher : undefined,
      provider: contentData ? contentData.provider : undefined
    };

    const graphContent = [];
    if (selectedOrgData) {
      graphContent.push(selectedOrgData);
    }
    if (selectedPersonData) {
      graphContent.push(selectedPersonData);
    }
    if (selectedWebsiteData) {
      graphContent.push(selectedWebsiteData);
    }
    graphContent.push(webPageData);

    if (contentData) {
        if (Object.keys(contentData).length > 0) {
            graphContent.push(contentData);
        }
    }
    else {
        console.warn(\`No schema.org data for path: \${location.pathname}\`);
    }

    graphData = {
      '@context': 'https://schema.org',
      '@graph': graphContent
    }

  return (
    <>
      {children}
      {graphData && (
        <script type='application/ld+json'>
          {JSON.stringify(graphData)}
        </script>
      )}
    </>
  );
}
  `;

  const middlePart: string = `
  const mainI18nData = ${JSON.stringify(mainI18nData, null, 2)};
  const homePathes = ${i18n ? 'locales.map(locale => locale === \'' + defaultLocale + '\' ? \'/\' : \'/\' + locale + \'/\')' : '[\'/\']'}; ;

  const schemas = {

    ${pagesData}

  }
  for (const homePath of homePathes) {
    schemas[homePath] = {};
  }
  `

  return startPart + middlePart + endPart;
}

// Supported schema.org types configuration
const SUPPORTED_SCHEMA_TYPES = {
  withAuthorPublisher: ['Article', 'BlogPosting', 'CollectionPage', 'Blog', 'AboutPage'],
  withProvider: ['Service', 'WebSite'],
  noEnrichment: ['Organization', 'Person'],
};

// Helper functions to process markdown files and extract schema data
function getData(context: DocsaurusContext, options: PluginOptions, docsDir: string, pathname: string): string {
  let pagesData: string = '';

  const processDir = (currentDir: string, currentPathname: string) => {
    try {
      if (!fs.existsSync(currentDir)) {
        logger('info', `Directory not found, skipping: ${currentDir}`, options.verbose);
        return;
      }

      const entries: any = fs.readdirSync(currentDir, { withFileTypes: true });
      entries.forEach((entry: any) => {
        const entryPath = path.join(currentDir, entry.name);
        try {
          if (entry.isDirectory()) {
            // Ajoute un slash à la fin du pathname si nécessaire
            const newPathname = currentPathname + entry.name + '/';
            processDir(entryPath, newPathname);
          } else if (entry.isFile() && (entry.name.endsWith('.md') || entry.name.endsWith('.mdx'))) {
            logger('info', `Processing doc file for schema: ${entryPath}`, options.verbose);
            const content = fs.readFileSync(entryPath, 'utf-8');
            const { data } = matter(content);
            logger('info', `Front matter data: ${JSON.stringify(data)}`, options.verbose);

            if (data.schema) {
              const pagePath = currentPathname + (data.slug || entry.name.replace(/\.mdx?$/, '')) + '/';
              logger('info', `Generating schema for: ${entryPath} -> ${pagePath}`, options.verbose);
              const schema = {
                '@type': data.schema.type || 'Article',
                headline: data.schema.headline || data.title || 'Untitled',
                image: context.siteConfig.url + '/' + (data.schema.image || data.image || options.defaultImage),
                description: data.schema.description || data.description || undefined,
                keywords: data.schema.keywords || undefined,
                datePublished: data.schema.datePublished || data.date || undefined,
                dateModified: data.schema.dateModified || data.date || undefined,
              }
              pagesData += `
    '${pagePath}': ${JSON.stringify(schema, null, 2)},
      `;
            }
          }
        } catch (error) {
          logger('error', `Error processing file ${entryPath}: ${error}`);
        }
      });
    } catch (error) {
      logger('error', `Error reading directory ${currentDir}: ${error}`);
    }
  };

  processDir(docsDir, pathname);
  return pagesData;
}

function getPagesData(context: DocsaurusContext, options: PluginOptions): string {
  // Use configured paths or defaults
  const SRC_DIR = options.srcDir ? path.join(context.siteDir, options.srcDir) : path.join(context.siteDir, 'src/pages');
  const BLOG_DIR = options.blogDir ? path.join(context.siteDir, options.blogDir) : path.join(context.siteDir, 'blog');
  const DOCS_DIR = options.docsDir ? path.join(context.siteDir, options.docsDir) : path.join(context.siteDir, 'docs');

  logger('info', `Using directories - src: ${SRC_DIR}, blog: ${BLOG_DIR}, docs: ${DOCS_DIR}`, options.verbose);

  let pagesData: string = '';
  pagesData += getData(context, options, SRC_DIR, '/');
  pagesData += getData(context, options, BLOG_DIR, '/blog/');
  pagesData += getData(context, options, DOCS_DIR, '/docs/');

  const i18n = context.i18n;
  if (i18n && i18n.locales) {
    i18n.locales.forEach((locale: string) => {
      if (locale !== i18n.defaultLocale) {
        const localeBlogDir = path.join(context.siteDir, 'i18n', locale, 'docusaurus-plugin-content-blog');
        const localeDocsDir = path.join(context.siteDir, 'i18n', locale, 'docusaurus-plugin-content-docs', 'current');
        const localeSrcDir = path.join(context.siteDir, 'i18n', locale, 'docusaurus-plugin-content-pages');
        pagesData += getData(context, options, localeSrcDir, `/${locale}/`);
        pagesData += getData(context, options, localeBlogDir, `/${locale}/blog/`);
        pagesData += getData(context, options, localeDocsDir, `/${locale}/docs/`);
      }
    });
  }
  return pagesData;
}

function generateDefautContent(context: DocsaurusContext): string {
  const defaultContent = {
    'website': {
      '@type': 'WebSite',
      '@id': `${context.siteConfig.url}/#website`,
      'url': `${context.siteConfig.url}/`,
      'name': `${context.siteConfig.title}`,
      'inLanguage': context.i18n && context.i18n.defaultLocale ? context.i18n.defaultLocale : 'en',
      'description': context.siteConfig.tagline ? context.siteConfig.tagline : '',
    }
  };

  return JSON.stringify(defaultContent);
}

// Main execution
export function run(context: DocsaurusContext, options: PluginOptions) {
  const DOCUSAURUS_CONFIG_URL = context.siteConfig.url;
  logger('info', `Using DOCUSAURUS_CONFIG_URL: ${DOCUSAURUS_CONFIG_URL}`, options.verbose);

  const SAME_AS_DEFAULT_STR = (options.sameAsDefault || []).toString();
  logger('info', `Using SAME_AS_DEFAULT: ${SAME_AS_DEFAULT_STR}`, options.verbose);

  const content = options.baseSchema ? JSON.stringify(options.baseSchema) : generateDefautContent(context);
  const mainData = JSON.parse(content.replace(/\${DOCUSAURUS_CONFIG_URL}/g, DOCUSAURUS_CONFIG_URL).replace(/\${SAME_AS_DEFAULT}/g, SAME_AS_DEFAULT_STR));

  const mainI18nData: Record<string, any> = {
    'default': {}
  };
  mainI18nData['default'].baseSchema = mainData;
  for (const key of Object.keys(options.i18n || {})) {
    const i18nData = options.i18n?.[key];
    if (i18nData) {
      mainI18nData[key] = JSON.parse(JSON.stringify(i18nData).replace(/\${DOCUSAURUS_CONFIG_URL}/g, DOCUSAURUS_CONFIG_URL).replace(/\${SAME_AS_DEFAULT}/g, SAME_AS_DEFAULT_STR));
    }
  }

  const pagesData = getPagesData(context, options).replace(/\${DOCUSAURUS_CONFIG_URL}/g, DOCUSAURUS_CONFIG_URL).replace(/\${SAME_AS_DEFAULT}/g, SAME_AS_DEFAULT_STR);
  logger('info', 'Generating Root.js with structured data...', options.verbose);
  const fileContent = generateFileContent(context, mainI18nData, pagesData);

  // Write to output file
  const OUTPUT_FILE_DEFAULT = path.join(context.siteDir, 'src/theme/Root.js');
  const outputFile = options.outputFile || OUTPUT_FILE_DEFAULT;

  try {
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
      logger('info', `Created output directory: ${outputDir}`, options.verbose);
    }
    fs.writeFileSync(outputFile, fileContent, 'utf-8');
    logger('info', `Root.js generated at: ${outputFile}`, options.verbose);
  } catch (error) {
    logger('error', `Error writing Root.js file: ${error}`);
    throw error;
  }
}
